# План тестирования — Bybit Algo-Grid / стратегия AVI-5

Документ описывает подход к тестированию системы **Bybit Algo-Grid System / стратегия AVI-5**:

- какие уровни тестирования используются;
- какие модули и сценарии подлежат проверке;
- какие требования (функциональные и нефункциональные) должны быть покрыты тестами;
- как тесты встраиваются в CI/CD и эксплуатацию.

Документ ориентирован на техническую команду (разработчики, QA, SRE).

---

## 1. Область охвата и цели

### 1.1. Область охвата

План тестирования распространяется на:

- backend-приложение (FastAPI, фоновые воркеры);
- торговую логику стратегии AVI-5 (сигналы, позиции, риск-ограничения, kill-switch);
- интеграцию с биржей Bybit (HTTP + WebSocket);
- хранение данных (PostgreSQL + TimescaleDB, Redis);
- подсистемы мониторинга, backup/restore и DR;
- обработку и хранение персональных данных (GDPR).

Фронтенд/UI входит в область, если явно оговорено в отдельных разделах, но основной акцент — на backend и интеграции.

### 1.2. Цели тестирования

- Подтвердить, что реализованные функции соответствуют спецификации и требованиям (R-xx, Q-xx, A-xx).
- Минимизировать риск финансовых потерь из-за ошибок торговой логики и интеграции с биржей.
- Обеспечить выполняемость целевых RTO/RPO и корректность backup/restore.
- Подтвердить соблюдение политики хранения персональных данных и GDPR-ограничений.

---

## 2. Уровни тестирования

### 2.1. Модульные тесты (unit tests)

- Покрывают:
  - чистые функции и сервисы (risk-логика, расчёт stake, slippage, агрегация сигналов);
  - Pydantic-схемы (`config/schema.py`, DTO для API);
  - утилитарные компоненты (JWT-подпись/проверка, валидация конфигов, сериализация).
- Не трогают реальные внешние ресурсы (БД, сеть, Bybit) — всё мокается/фейкуется.

### 2.2. Интеграционные тесты

- Проверяют корректность взаимодействия между:
  - API и слоем доступа к данным (репозитории + БД);
  - торговой логикой и Bybit-клиентами (через тестовый double/интеграционный стенд);
  - backup/restore-скриптами и фактической БД;
  - monitoring-эндпоинтами и экспортируемыми метриками.
- Используют реальную тестовую БД и Redis (контейнеры или отдельные инстансы).

### 2.3. Системные / E2E тесты

- Имитация жизненного цикла:
  - создание пользователя → логин → включение 2FA → создание API-ключа → получение сигналов → открытие/закрытие позиций → проверка reconciliation.
- Запуск в окружении, максимально близком к стэйдж/прод (docker-compose или Kubernetes).

### 2.4. Нефункциональные тесты

- Нагрузочные: проверка латентности и устойчивости при увеличении количества сигналов/позиций.
- Отказоустойчивость: проверки сценариев DR/backup.
- Безопасность: базовые проверки RBAC, 2FA, ограничения по API-ключам.
- Мониторинг: проверка метрик и алертов.

---

## 3. Окружения и тестовые данные

### 3.1. Окружения

- **Dev** — для локальной разработки, быстрых unit/integration тестов.
- **Staging** — максимально близок к продакшену:
  - отдельная БД, Redis;
  - близкие настройки по ресурсам/конфигурации;
  - использует sandbox-окружение Bybit (testnet) или mock-сервер.
- **Prod** — используется только для read-only health-check’ов, мониторинга и, при необходимости, A/B-верификаций (без генерации тестовых сделок).

### 3.2. Тестовые данные

- Пользователи:
  - минимум по одному пользователю каждой роли (`viewer`, `trader`, `admin`);
  - набор пользователей с включённой и отключённой 2FA.
- Торговые данные:
  - синтетические сигналы для нескольких символов (`BTCUSDT`, `ETHUSDT`, др.);
  - набор позиций с разными статусами (`open`, `closing`, `closed`, `error`).
- API-ключи:
  - валидные ключи для Bybit testnet;
  - заведомо неверные/просроченные ключи для негативных сценариев.

---

## 4. Модульные тесты (перечень по модулям)

### 4.1. Конфигурация и валидация (`config/schema.py`, loader)

**Цели:**

- Проверить, что конфигурация из `config/settings.yaml` корректно валидируется.
- Обеспечить отказоустойчивость при отсутствии/повреждении конфигов.

**Примеры тестов:**

- `CFG-01` — успешная валидация минимального корректного конфига.
- `CFG-02` — ошибка при `trading.max_stake <= 0`.
- `CFG-03` — ошибка при `risk.max_concurrent < 1`.
- `CFG-04` — ошибка при отсутствующем `bybit.api_key`.
- `CFG-05` — отказ при наличии неизвестных полей (extra = "forbid").

### 4.2. Аутентификация и JWT

**Цели:**

- Проверить корректность генерации и валидации JWT.
- Проверить истечение токенов и refresh-механику.

**Примеры тестов:**

- `AUTH-01` — успешное создание access/refresh токенов по валидному пользователю.
- `AUTH-02` — ошибка при некорректном пароле.
- `AUTH-03` — истечение access_token по `exp`.
- `AUTH-04` — успешный refresh по валидному refresh_token.
- `AUTH-05` — отказ refresh при отозванном/просроченном токене.

### 4.3. RBAC и роли

**Цели:**

- Проверить, что роли `viewer` / `trader` / `admin` соответствуют матрице доступа.

**Примеры тестов:**

- `RBAC-01` — `viewer` может выполнять `GET /signals`, но не `POST /positions/{id}/close`.
- `RBAC-02` — `trader` может закрывать позиции, но не менять `/config`.
- `RBAC-03` — `admin` имеет доступ к `/users`, `/config` (PATCH), `/admin/kill_switch`.

### 4.4. 2FA (TOTP)

**Цели:**

- Проверить lifecycle 2FA: setup → confirm → require on login → disable.

**Примеры тестов:**

- `2FA-01` — генерация otpauth_uri и временного секрета (`POST /auth/2fa/setup`).
- `2FA-02` — успешное подтверждение кода (`POST /auth/2fa/confirm`).
- `2FA-03` — отказ логина без 2FA при включённой 2FA для пользователя.
- `2FA-04` — успешное отключение 2FA по корректному коду (`POST /auth/2fa/disable`).

### 4.5. Торговая логика: сигналы и позиции

**Цели:**

- Проверить корректность расчётов stake, TP/SL, PnL.
- Проверить переходы статусов позиций.

**Примеры тестов:**

- `TRD-01` — корректный расчёт stake_usd в зависимости от `trading.max_stake` и настроек риска.
- `TRD-02` — ограничения по `risk.max_concurrent` не допускают открытие новой позиции сверх лимита.
- `TRD-03` — корректный расчёт `pnl_usd` при закрытии позиции.
- `TRD-04` — корректные статусы: `open` → `closing` → `closed` / `error`.

### 4.6. Kill-switch

**Цели:**

- Гарантировать, что kill-switch останавливает торговлю.

**Примеры тестов:**

- `KS-01` — при `kill_switch_active = true` новые торговые сигналы не приводят к открытию позиций.
- `KS-02` — админ может включать/выключать kill-switch через `/admin/kill_switch`.
- `KS-03` — состояние kill-switch отражается в метриках и алертах.

### 4.7. Работа с Bybit (бизнес-логика клиентских обёрток)

**Цели:**

- Не вылезать за лимиты API.
- Корректно обрабатывать разные классы ошибок.

**Примеры тестов (с mocked HTTP/WS):**

- `BYBIT-01` — успешное размещение ордера и маппинг ответа в доменную модель.
- `BYBIT-02` — повторные попытки при временных 5xx.
- `BYBIT-03` — корректное логирование и классификация `order_rejections` по коду/сообщению.

---

## 5. Интеграционные тесты

### 5.1. REST API

**Цели:**

- Проверить, что REST-эндпоинты соответствуют `docs/api.md`.
- Проверить маршрутизацию, валидацию и интеграцию с БД.

**Примеры сценариев:**

- `API-01` — полный сценарий логина (`/auth/login`), получения токенов, обращения к защищённому эндпоинту, обновления токена (`/auth/refresh`) и логаута (`/auth/logout`).
- `API-02` — CRUD-сценарии для пользователей (`/users` GET/POST/PATCH).
- `API-03` — чтение и изменение конфигурации (`/config` GET/PATCH) с логированием в `audit_trail`.
- `API-04` — управление API-ключами (`/api-keys` GET/POST/DELETE).

### 5.2. Сигналы и позиции (E2E через БД и API)

**Примеры:**

- `SIGPOS-01` — запись сигнала в БД → корректное отображение в `GET /signals` с фильтрами.
- `SIGPOS-02` — создание позиции на основе сигнала → отображение в `GET /positions`.
- `SIGPOS-03` — закрытие позиции через `POST /positions/{id}/close` → обновление статуса и PnL.

### 5.3. SSE-стрим `/stream`

**Цели:**

- Проверить корректность SSE-событий для сигналов и позиций.

**Примеры:**

- `SSE-01` — появление нового сигнала → клиент получает `event: signal`.
- `SSE-02` — изменение статуса позиции → клиент получает `event: position`.
- `SSE-03` — восстановление соединения и корректная работа после reconnect.

### 5.4. Monitoring: `/health` и `/metrics`

**Цели:**

- Убедиться, что healthcheck отражает состояние зависимостей.
- Проверить корректность базовых метрик.

**Примеры:**

- `MON-01` — при доступной БД и Redis `/health` возвращает `status: "ok"`.
- `MON-02` — при недоступной БД `/health` возвращает `503`, метрика ошибки увеличивается.
- `MON-03` — метрики по Bybit, kill-switch и WS трафику присутствуют и отдаются Prometheus’у.

---

## 6. Тестирование backup/restore и DR

### 6.1. Backup-скрипты

**Цели:**

- Проверить корректность дневных backup’ов и WAL-архивирования.

**Примеры:**

- `BK-01` — успешный запуск `scripts/backup.py`, появление архива в локальном каталоге и S3.
- `BK-02` — корректная ротация backup’ов в соответствии с retention-политикой.

### 6.2. Restore и RPO

**Цели:**

- Подтвердить достижимость RPO = 5 минут.

**Примеры:**

- `BK-03` — восстановление БД через `scripts/restore_db.sh <backup_timestamp>` до заданной точки;
- `BK-04` — проверка целостности данных после восстановления (наличие ключевых таблиц, консистентность).

### 6.3. DR-сценарии (в связке с `docs/disaster_recovery.md`)

- Имитировать отказ узла БД, восстановление на новый инстанс и переключение приложения.
- Имитировать отказ узла приложения, перезапуск через docker-compose / Kubernetes и проверку `/health`.

---

## 7. Тестирование безопасности и GDPR

### 7.1. Безопасность

**Примеры сценариев:**

- `SEC-01` — попытка доступа к админским эндпоинтам без роли `admin` → `403`.
- `SEC-02` — попытка входа с неверным паролем/2FA → корректный `401`, без утечки деталей.
- `SEC-03` — проверка, что логирование не содержит паролей, секретов 2FA, приватных ключей.

### 7.2. GDPR и Right to be forgotten

В соответствии с `docs/gdpr_compliance.md`:

- `GDPR-01` — анонимизация учётной записи (`users`) по запросу: email заменён, 2FA-секреты удалены, `is_active = false`.
- `GDPR-02` — анонимизация ссылок на пользователя в `audit_trail` и торговых данных.
- `GDPR-03` — проверка, что после анонимизации новые события не привязываются к старому `user_id`.

---

## 8. Автоматизация и CI

### 8.1. CI-конвейер

CI описан в `.github/workflows/ci.yml` и включает:

- job `lint` — запуск `ruff` и `mypy`;
- job `test` — запуск `pytest` с поднятыми контейнерами PostgreSQL и Redis;
- job `build` — сборка Docker-образа.

### 8.2. Обязательные проверки перед merge в main

- зелёный прогон unit и integration тестов;
- статический анализ (ruff, mypy) без ошибок;
- успешная сборка Docker-образа.

### 8.3. Регулярные проверки

- Ночные или еженедельные прогоны расширенного набора тестов (включая E2E и DR-учения) на staging.

---

## 9. Поддержка и актуализация плана

- Любое изменение архитектуры, схемы БД, API или требований к безопасности должно сопровождаться обновлением соответствующих разделов данного документа.
- Для новых модулей/сервисов необходимо:
  - добавить описание в `docs/database_schema.md` / `docs/api.md` / `docs/deployment.md`;
  - расширить настоящий план тестирования новыми тест-кейсами или группами кейсов.
- Ответственность за актуальность документа несут тимлид и ответственные за качество (QA/DevOps).
